name: "Update Manifest and Commit Changes"
description: "Checks out the repository, sets up Node, installs dependencies, updates manifest.json, formats, and commits/pushes changes signing the commit."
inputs:
  manifestPath:
    description: "The path to the manifest.json file."
    required: false
    default: "${{ github.workspace }}/manifest.json"
  schemaPath:
    description: "The path to the plugin settings schema."
    required: false
    default: "${{ github.workspace }}/src/types/plugin-input.ts"
  pluginEntry:
    description: "The path to the plugin entry file."
    required: false
    default: "${{ github.workspace }}/src/index.ts"
  commitMessage:
    description: "The commit message."
    required: false
    default: "chore: updated manifest.json and dist build"
  nodeVersion:
    description: "The version of Node.js to use."
    default: "20.10.0"
  treatAsEsm:
    description: "If the package is set to be treated as ESM, it will replace __dirname occurrences."
    default: false
  sourcemap:
    description: "Generates the sourcemap for the compiled files"
outputs: {}
runs:
  using: "composite"
  steps:
    - name: Check out the repository
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.nodeVersion }}

    - uses: oven-sh/setup-bun@v2

    - name: Install dependencies
      shell: bash
      run: |
        bun install --frozen-lockfile

    - name: Build project
      shell: bash
      run: |
        bun add -DE @vercel/ncc
        echo "Compiling plugin..."
        bun ncc build ${{ inputs.pluginEntry }} --external "./tests" -m ${{ inputs.sourcemap == 'true' && '-s' || '' }} -o dist
        echo "Compiling plugin types..."
        bun ncc build ${{ inputs.schemaPath }} --external "./tests" -m -o plugin

    - name: Replace __dirname with import.meta.dirname
      if: ${{ inputs.treatAsEsm }}
      shell: bash
      run: |
        if [ "${{ inputs.treatAsEsm }}" = "true" ]; then
          sed -i 's/__dirname/import.meta.dirname/g' "${{ github.workspace }}/dist/index.js"
        fi

    - name: Update manifest configuration JSON
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs').promises;
          const path = require('path');

          async function updateManifest() {
            const manifestPath = '${{ inputs.manifestPath }}';
            const pluginPath = path.resolve('${{ github.workspace }}', 'plugin', 'index.js');

            let pluginSettingsSchema;
            try {
              // First, try to load as ESM
              try {
                const pluginModule = await import(`file://${pluginPath}`);
                pluginSettingsSchema = pluginModule.pluginSettingsSchema;

                if (!pluginSettingsSchema) {
                  throw new Error('pluginSettingsSchema not found in the ESM module');
                }
              } catch (esmError) {
                // If ESM import fails, try loading as CJS
                try {
                  const pluginModule = require(pluginPath);
                  pluginSettingsSchema = pluginModule.pluginSettingsSchema;

                  if (!pluginSettingsSchema) {
                    throw new Error('pluginSettingsSchema not found in the CJS module');
                  }
                } catch (cjsError) {
                  console.error('Error loading module as ESM and CJS:', esmError, cjsError);
                  process.exit(1);
                }
              }
            } catch (error) {
              console.error('Error loading module:', error);
              process.exit(1);
            }

            const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf8'));
            manifest["configuration"] = pluginSettingsSchema;

            function customReviver(key, value) {
              if (typeof value === "object" && value !== null) {
                if ("properties" in value && "required" in value) {
                  const requiredFields = new Set(value.required);
                  for (const [propKey, propValue] of Object.entries(value.properties)) {
                    if (typeof propValue === 'object' && 'default' in propValue) {
                      requiredFields.delete(propKey);
                    }
                  }
                  value.required = Array.from(requiredFields);
                  if (value.required.length === 0) {
                    delete value.required;
                  }
                }

                // Recursively apply to nested objects and arrays
                if (Array.isArray(value)) {
                  return value.map(item => JSON.parse(JSON.stringify(item), customReviver));
                } else {
                  return Object.fromEntries(
                    Object.entries(value).map(([k, v]) => [k, JSON.parse(JSON.stringify(v), customReviver)])
                  );
                }
              }
              return value;
            }

            const updatedManifest = JSON.stringify(manifest, customReviver, 2);
            await fs.writeFile(manifestPath, updatedManifest, 'utf8');
          }
          updateManifest();

    - name: Format manifest using Prettier
      shell: bash
      run: |
        bun add -DE prettier
        bun prettier --write .

    - name: Get GitHub App token
      if: env.APP_ID != '' && env.APP_PRIVATE_KEY != ''
      uses: tibdex/github-app-token@v1.7.0
      id: get_installation_token
      with:
        app_id: ${{ env.APP_ID }}
        private_key: ${{ env.APP_PRIVATE_KEY }}

    - name: Install dependencies for GitHub Auth
      shell: bash
      run: |
        bun add "@actions/github" glob

    - name: Update manifest.json and dist folder
      shell: bash
      env:
        GITHUB_TOKEN: ${{ steps.get_installation_token.outputs.token || github.token }}
      run: |
        git add "${{ inputs.manifestPath }}"
        find ${{ github.workspace }}/dist \( -name "*.js" -o -name "*.cjs" -o -name "*.map" -o -name "*.json" \) -print0 | xargs -0 git add -f
        echo "Changed files:"
        echo "$(git diff-index --cached --name-only HEAD)"
        if [ -n "$(git diff-index --cached --name-only HEAD)" ]; then
          node -e "
            const fs = require('fs');
            const path = require('path');
            const github = require('@actions/github');
            const glob = require('glob');
            const manifestPath = path.relative('.', '${{ inputs.manifestPath }}');

            async function sleep(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }

            async function retryWithBackoff(operation, maxRetries = 5) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await operation();
                } catch (error) {
                  const errorMessage = error.response?.data?.message || error.message || 'Unknown error';
                  console.error(`Attempt ${attempt} failed: ${errorMessage}`);
                  
                  if (attempt === maxRetries) {
                    console.error('Maximum retries reached. Failing operation.');
                    throw error;
                  }
                  
                  // Exponential backoff with jitter
                  const baseDelay = 1000;
                  const maxDelay = 30000; // 30 seconds max delay
                  const exponentialDelay = baseDelay * Math.pow(2, attempt - 1);
                  const jitter = Math.random() * 1000;
                  const delayMs = Math.min(exponentialDelay + jitter, maxDelay);
                  
                  console.log(`Retrying in ${Math.round(delayMs)}ms...`);
                  await sleep(delayMs);
                }
              }
            }

            async function pushChanges() {
              const octokit = github.getOctokit(process.env.GITHUB_TOKEN);
              const context = github.context;
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              const ref = 'heads/${{ github.ref_name }}';

              try {
                const currentCommit = await octokit.rest.git.getRef({
                  owner,
                  repo,
                  ref
                });

                // Prepare all tree entries
                console.log('Adding file:', manifestPath);
                const distPath = '${{ github.workspace }}/dist/';
                const distFiles = glob.sync(distPath + '**/*.{js,cjs,map,json}');
                const allTreeEntries = [
                  {
                    path: manifestPath,
                    mode: '100644',
                    type: 'blob',
                    content: fs.readFileSync(manifestPath, 'utf8'),
                  }
                ];

                for (const file of distFiles) {
                  const relativePath = path.relative('.', file);
                  console.log('Adding file:', relativePath);
                  allTreeEntries.push({
                    path: relativePath,
                    mode: '100644',
                    type: 'blob',
                    content: fs.readFileSync(file, 'utf8'),
                  });
                }

                const chunkSize = 5;
                const maxChunkBytes = 250 * 1024;
                const treeEntryChunks = [];
                let currentChunk = [];
                let currentChunkSize = 0;

                for (const entry of allTreeEntries) {
                  const entrySize = Buffer.byteLength(entry.content, 'utf8');
                  
                  if (currentChunk.length >= chunkSize || currentChunkSize + entrySize > maxChunkBytes) {
                    if (currentChunk.length > 0) {
                      treeEntryChunks.push(currentChunk);
                      currentChunk = [];
                      currentChunkSize = 0;
                    }
                  }
                  
                  currentChunk.push(entry);
                  currentChunkSize += entrySize;
                }

                if (currentChunk.length > 0) {
                  treeEntryChunks.push(currentChunk);
                }

                const totalBytes = allTreeEntries.reduce((acc, entry) => acc + Buffer.byteLength(entry.content, 'utf8'), 0);
                console.log(`Processing ${allTreeEntries.length} files (total size: ${Math.round(totalBytes/1024)}KB) in ${treeEntryChunks.length} chunks`);

                let currentTreeSha = currentCommit.data.object.sha;
                for (let i = 0; i < treeEntryChunks.length; i++) {
                  const chunk = treeEntryChunks[i];
                  const chunkIndex = i + 1;
                  const chunkBytes = chunk.reduce((acc, entry) => acc + Buffer.byteLength(entry.content, 'utf8'), 0);
                  console.log(`Processing chunk ${chunkIndex} of ${treeEntryChunks.length} (${chunk.length} files, ${Math.round(chunkBytes/1024)}KB)`);
                  
                  let retryCount = 0;
                  const maxRetries = 3;
                  
                  while (retryCount <= maxRetries) {
                    try {
                      const newTree = await retryWithBackoff(() => 
                        octokit.rest.git.createTree({
                          owner,
                          repo,
                          base_tree: currentTreeSha,
                          tree: chunk,
                        })
                      );
                      
                      currentTreeSha = newTree.data.sha;
                      console.log(`Successfully processed chunk ${chunkIndex}`);
                      break; // Success, exit retry loop
                      
                    } catch (error) {
                      retryCount++;
                      const errorMessage = error.response?.data?.message || error.message || 'Unknown error';
                      console.error(`Error processing chunk ${chunkIndex} (attempt ${retryCount}/${maxRetries + 1}): ${errorMessage}`);
                      
                      if (retryCount > maxRetries) {
                        throw error; // Max retries exceeded, propagate error
                      }
                      
                      // Wait longer between chunk retries
                      const delayMs = Math.min(10000 * Math.pow(2, retryCount - 1), 30000);
                      console.log(`Waiting ${Math.round(delayMs/1000)}s before retrying chunk...`);
                      await sleep(delayMs);
                    }
                  }
                }

                console.log('Creating commit...');
                const newCommit = await retryWithBackoff(() => octokit.rest.git.createCommit({
                  owner,
                  repo,
                  message: '${{ inputs.commitMessage }}',
                  tree: currentTreeSha,
                  parents: [currentCommit.data.object.sha]
                }));

                await retryWithBackoff(() => octokit.rest.git.updateRef({
                  owner,
                  repo,
                  ref,
                  sha: newCommit.data.sha,
                  force: true
                }));
                console.log('Repository reference updated successfully');

                console.log('Changes pushed successfully');
              } catch (error) {
                console.error('Error pushing changes:', error);
                process.exit(1);
              }
            }

            pushChanges();
          "
        else
          echo "No changes to commit"
        fi
