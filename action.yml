name: "Update Manifest and Commit Changes"
description: "Checks out the repository, sets up Node, installs dependencies, updates manifest.json, formats, and commits/pushes changes signing the commit."
inputs:
  manifestPath:
    description: "The path to the manifest.json file."
    required: false
    default: "${{ github.workspace }}/manifest.json"
  schemaPath:
    description: "The path to the plugin settings schema."
    required: false
    default: "${{ github.workspace }}/src/types/plugin-input.ts"
  pluginEntry:
    description: "The path to the plugin entry file."
    required: false
    default: "${{ github.workspace }}/src/index.ts"
  commitMessage:
    description: "The commit message."
    required: false
    default: "chore: updated manifest.json and dist build"
  nodeVersion:
    description: "The version of Node.js to use."
    default: "20.10.0"
  treatAsEsm:
    description: "If the package is set to be treated as ESM, it will replace __dirname occurrences."
    default: false
  sourcemap:
    description: "Generates the sourcemap for the compiled files"
outputs: {}
runs:
  using: "composite"
  steps:
    - name: Check out the repository
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.nodeVersion }}

    - uses: oven-sh/setup-bun@v2

    - name: Install dependencies
      shell: bash
      run: |
        bun install --frozen-lockfile

    - name: Build project
      shell: bash
      run: |
        bun add -DE @vercel/ncc
        echo "Compiling plugin..."
        bun ncc build ${{ inputs.pluginEntry }} --external "./tests" -m ${{ inputs.sourcemap == 'true' && '-s' || '' }} -o dist
        echo "Compiling plugin types..."
        bun ncc build ${{ inputs.schemaPath }} --external "./tests" -m -o plugin

    - name: Replace __dirname with import.meta.dirname
      if: ${{ inputs.treatAsEsm }}
      shell: bash
      run: |
        if [ "${{ inputs.treatAsEsm }}" = "true" ]; then
          sed -i 's/__dirname/import.meta.dirname/g' "${{ github.workspace }}/dist/index.js"
        fi

    - name: Update manifest configuration JSON
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs').promises;
          const path = require('path');

          async function updateManifest() {
            const manifestPath = '${{ inputs.manifestPath }}';
            const pluginPath = path.resolve('${{ github.workspace }}', 'plugin', 'index.js');

            let pluginSettingsSchema;
            try {
              // First, try to load as ESM
              try {
                const pluginModule = await import(`file://${pluginPath}`);
                pluginSettingsSchema = pluginModule.pluginSettingsSchema;

                if (!pluginSettingsSchema) {
                  throw new Error('pluginSettingsSchema not found in the ESM module');
                }
              } catch (esmError) {
                // If ESM import fails, try loading as CJS
                try {
                  const pluginModule = require(pluginPath);
                  pluginSettingsSchema = pluginModule.pluginSettingsSchema;

                  if (!pluginSettingsSchema) {
                    throw new Error('pluginSettingsSchema not found in the CJS module');
                  }
                } catch (cjsError) {
                  console.error('Error loading module as ESM and CJS:', esmError, cjsError);
                  process.exit(1);
                }
              }
            } catch (error) {
              console.error('Error loading module:', error);
              process.exit(1);
            }

            const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf8'));
            manifest["configuration"] = pluginSettingsSchema;

            function customReviver(key, value) {
              if (typeof value === "object" && value !== null) {
                if ("properties" in value && "required" in value) {
                  const requiredFields = new Set(value.required);
                  for (const [propKey, propValue] of Object.entries(value.properties)) {
                    if (typeof propValue === 'object' && 'default' in propValue) {
                      requiredFields.delete(propKey);
                    }
                  }
                  value.required = Array.from(requiredFields);
                  if (value.required.length === 0) {
                    delete value.required;
                  }
                }

                // Recursively apply to nested objects and arrays
                if (Array.isArray(value)) {
                  return value.map(item => JSON.parse(JSON.stringify(item), customReviver));
                } else {
                  return Object.fromEntries(
                    Object.entries(value).map(([k, v]) => [k, JSON.parse(JSON.stringify(v), customReviver)])
                  );
                }
              }
              return value;
            }

            const updatedManifest = JSON.stringify(manifest, customReviver, 2);
            await fs.writeFile(manifestPath, updatedManifest, 'utf8');
          }
          updateManifest();

    - name: Format manifest using Prettier
      shell: bash
      run: |
        bun add -DE prettier
        bun prettier --write .

    - name: Get GitHub App token
      if: env.APP_ID != '' && env.APP_PRIVATE_KEY != ''
      uses: tibdex/github-app-token@v1.7.0
      id: get_installation_token
      with:
        app_id: ${{ env.APP_ID }}
        private_key: ${{ env.APP_PRIVATE_KEY }}

    - name: Install dependencies for GitHub Auth
      shell: bash
      run: |
        bun add "@actions/github" glob

    - name: Configure Git
      shell: bash
      run: |
        git config --global user.name "github-actions"
        git config --global user.email "github-actions@github.com"

    - name: Update manifest.json and dist folder
      shell: bash
      env:
        GITHUB_TOKEN: ${{ steps.get_installation_token.outputs.token || github.token }}
      run: |
        # Create a temporary directory for the clone
        TEMP_DIR=$(mktemp -d)
        echo "Created temporary directory: $TEMP_DIR"

        # Clone the repository
        echo "Cloning repository to temporary directory..."
        git clone "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git" "$TEMP_DIR"
        cd "$TEMP_DIR"

        # Store the current branch name
        CURRENT_BRANCH="${{ github.ref_name }}"
        
        # Function to ensure cleanup happens even on error
        cleanup() {
          echo "Cleaning up..."
          git push origin --delete temp_staging || true
          cd "${{ github.workspace }}"
          rm -rf "$TEMP_DIR"
        }
        trap cleanup EXIT

        # Create an orphan branch to stage files
        echo "Creating temporary orphan branch..."
        git checkout --orphan temp_staging
        
        # Clean the working directory in the orphan branch
        git rm -rf .
        
        # Create empty directories
        mkdir -p dist

        # Copy and commit manifest first
        echo "Processing manifest.json..."
        cp "${{ github.workspace }}/${{ inputs.manifestPath }}" .
        git add "${{ inputs.manifestPath }}"
        git commit -m "Add manifest.json"
        git push origin temp_staging

        # Process dist files in batches
        echo "Processing dist folder files..."
        
        # First, copy all dist files
        cp -r "${{ github.workspace }}/dist/"* dist/
        
        # Get total number of files for progress reporting
        TOTAL_FILES=$(find dist -type f | wc -l)
        PROCESSED_FILES=0
        BATCH_SIZE=5
        CURRENT_BATCH=0
        
        # Process files in batches
        find dist -type f -print0 | sort -z | while IFS= read -r -d '' file; do
          REL_PATH=$(realpath --relative-to="$PWD" "$file")
          ((PROCESSED_FILES++))
          ((CURRENT_BATCH++))
          
          echo "[${PROCESSED_FILES}/${TOTAL_FILES}] Adding file: $REL_PATH"
          git add -f "$REL_PATH"
          
          if [ $CURRENT_BATCH -ge $BATCH_SIZE ] || [ $PROCESSED_FILES -eq $TOTAL_FILES ]; then
            echo "Creating batch commit (files ${PROCESSED_FILES-CURRENT_BATCH+1}-${PROCESSED_FILES})..."
            git commit -m "Add dist files batch ${PROCESSED_FILES-CURRENT_BATCH+1}-${PROCESSED_FILES}"
            git push origin temp_staging
            CURRENT_BATCH=0
            echo "Batch pushed successfully"
          fi
        done || exit 1  # Ensure script fails if the loop fails

        # Verify all files were processed
        if [ $PROCESSED_FILES -ne $TOTAL_FILES ]; then
          echo "Error: Not all files were processed ($PROCESSED_FILES of $TOTAL_FILES)"
          exit 1
        fi

        # Switch back to the original branch and create final commit
        echo "Creating final commit on $CURRENT_BRANCH..."
        git checkout "$CURRENT_BRANCH"
        git add "${{ inputs.manifestPath }}"
        git add -f dist/
        
        # Only commit if there are changes
        if git diff --cached --quiet; then
          echo "No changes to commit"
        else
          git commit -m "${{ inputs.commitMessage }}"
          git push origin "$CURRENT_BRANCH"
          echo "Changes pushed successfully"
        fi
